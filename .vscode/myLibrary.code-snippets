{
	"fft":{
		"scope": "cpp",
		"prefix": "@fft",
		"body": [
			"struct FFT{",
			"\tstruct mycomplex{   ",
			"\t\tdouble real;",
			"\t\tdouble imag;",
			"\t\tmycomplex(double a=0.0,double b=0.0):real(a),imag(b){}",
			"\t\tmycomplex operator-() const {return mycomplex(-real,-imag);}",
			"\t\tmycomplex &operator+=(const mycomplex &a){real+=a.real;imag+=a.imag;return *this;}",
			"\t\tmycomplex &operator-=(const mycomplex &a){real-=a.real;imag-=a.imag;return *this;}",
			"\t\tmycomplex &operator*=(const mycomplex &a){double nr=real*a.real-imag*a.imag;double ni=real*a.imag+imag*a.real;real=nr;imag=ni;return *this;}",
			"\t\tmycomplex &operator/=(const mycomplex &a){double nr=(real*a.real+imag*a.imag)/(a.real*a.real+a.imag*a.imag);double ni=(imag*a.real-real*a.imag)/(a.real*a.real+a.imag*a.imag);real=nr;imag=ni;return *this;}",
			"\t\tmycomplex &operator*=(const double &a){real*=a;imag*=a;return *this;}",
			"\t\tmycomplex &operator/=(const double &a){real/=a;imag/=a;return *this;}",
			"\t\tmycomplex operator+(const mycomplex &a) const {return mycomplex(*this)+=a;}",
			"\t\tmycomplex operator-(const mycomplex &a) const {return mycomplex(*this)-=a;}",
			"\t\tmycomplex operator*(const mycomplex &a) const {return mycomplex(*this)*=a;}",
			"\t\tmycomplex operator/(const mycomplex &a) const {return mycomplex(*this)/=a;}",
			"\t\tmycomplex operator*(const double &a) const {return mycomplex(*this)*=a;}",
			"\t\tmycomplex operator/(const double &a) const {return mycomplex(*this)/=a;}",
			"\t\tmycomplex conj() const {return mycomplex(real,-imag);}",
			"\t\tmycomplex polar(double r,double q) const {return mycomplex(r*cos(q),r*sin(q));}",
			"\t};",
			"\t",
			"\ttypedef mycomplex clx;",
			"",
			"\tvector<clx> dft(vector<clx> f,int n,bool inverse=false){",
			"\t\tif(n==1)return f;",
			"\t\tvector<clx> a0,a1;",
			"\t\trep(i,n)i%2==0?a0.push_back(f[i]):a1.push_back(f[i]);",
			"\t\ta0=dft(a0,n/2,inverse);",
			"\t\ta1=dft(a1,n/2,inverse);",
			"\t\tclx zeta(cos(2*pi/n),sin(2*pi/n));",
			"\t\tif(inverse)zeta=zeta.conj();",
			"\t\tclx x=clx(1);",
			"\t\trep(i,n){",
			"\t\t\tf[i]=a0[i%(n/2)]+x*a1[i%(n/2)];",
			"\t\t\tx*=zeta;",
			"\t\t}",
			"\t\treturn f;",
			"\t}",
			"\tvector<double> operator()(vector<double> a,vector<double> b){",
			"\t\tint ma=a.size(),mb=b.size();",
			"\t\tll N=1;",
			"\t\tfor(N;N<=ma+mb+1;N*=2);",
			"\t\t//0を詰める",
			"\t\tvector<clx> aa(N,clx()),bb(N,clx());",
			"\t\tfor(int i=0;i<ma;i++)aa[i]=clx(a[i]);",
			"\t\tfor(int i=0;i<mb;i++)bb[i]=clx(b[i]);",
			"",
			"\t\taa=dft(aa,N);",
			"\t\tbb=dft(bb,N);",
			"",
			"\t\tvector<clx> res;",
			"\t\trep(i,N+1)res.push_back(aa[i]*bb[i]);",
			"",
			"\t\tres=dft(res,N,true);",
			"",
			"\t\tvector<double> ans;",
			"\t\trep(i,N+1)ans.push_back(res[i].real/N);",
			"\t\treturn ans;",
			"\t}",
			"};",
		],
	},
	"uftree":{
		"scope": "cpp",
		"prefix": "@uftree",
		"body": [
			"struct uftree{",
			"\tint cou;",
			"\tvector<int> parent;",
			"\tvector<int> rank;",
			"\tvector<int> _size;",
			"\tuftree(int n){",
			"\t\tinit(n);",
			"\t}",
			"\tvoid init(const int &n){",
			"\t\tparent=vector<int>(n);",
			"\t\trank=vector<int>(n,0);",
			"\t\t_size=vector<int>(n,1);",
			"\t\tcou=n;",
			"\t\trep(i,n){",
			"\t\t\tparent[i]=i;",
			"\t\t}",
			"\t}",
			"\tint root(const int &i){",
			"\t\treturn parent[i]==i?i:parent[i]=root(parent[i]);",
			"\t}",
			"\tbool same(const int &i,const int &j){",
			"\t\treturn root(i)==root(j);",
			"\t}",
			"\tvoid merge(int i,int j){",
			"\t\ti=root(i);j=root(j);",
			"\t\tif(i==j)return;",
			"\t\tcou--;",
			"\t\tif(rank[i]>=rank[j]){",
			"\t\t\tparent[j]=i;",
			"\t\t\t_size[i]+=_size[j];",
			"\t\t}else{",
			"\t\t\tparent[i]=j;",
			"\t\t\t_size[j]+=_size[i];",
			"\t\t}",
			"\t\tif(rank[i]==rank[j])rank[i]++;",
			"\t\treturn;",
			"\t}",
			"\tint count(){",
			"\t\treturn cou;",
			"\t}",
			"\tint unitsize(const int &i){",
			"\t\treturn _size[root(i)];",
			"\t}",
			"};",
		],
		"description": "Union-Find tree"
	},
	"divNum":{
		"scope": "cpp",
		"prefix": "@divNum",
		"body": [
			"struct divNum{",
			"\tvector<vector<mint>> d;",
			"\tint N, M;",
			"\tdivNum(int n, int m, bool tof=true) : d(n + 1, vector<mint>(m + 1, 0)){",
			"\t\tN = n;",
			"\t\tM = m;",
			"\t\tif (tof){",
			"\t\t\trep(j, n + 1){",
			"\t\t\t\td[j][0] = 1;",
			"\t\t\t}rep(j, m){",
			"\t\t\t\td[0][j + 1] = 0;",
			"\t\t\t}",
			"\t\t\tfor (int j = 1; j <= n; j++){",
			"\t\t\t\tfor (int k = 1; k <= m; k++){",
			"\t\t\t\t\tif (j > k)",
			"\t\t\t\t\t\td[j][k] = d[j - 1][k];",
			"\t\t\t\t\telse",
			"\t\t\t\t\t\td[j][k] = d[j - 1][k] + d[j][k - j];",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}else{",
			"\t\t\td[0][0] = 1;",
			"\t\t\trep(i, n){",
			"\t\t\t\trep(j, m + 1){",
			"\t\t\t\t\trep(k, m - j + 1){",
			"\t\t\t\t\t\td[i + 1][j + k] = d[i + 1][j + k] + d[i][j];",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tmint operator()(int n, int m){",
			"\t\tif (n < 0 || m < 0 || n > N || m > M)",
			"\t\t\treturn 0;",
			"\t\telse{",
			"\t\t\treturn d[n][m];",
			"\t\t}",
			"\t}",
			"};",
		],
		"description": "分割数table"
	},
	"strcmp2":{
		"scope": "cpp",
		"prefix": "@strcmp2",
		"body": [
			"//comparison s and t regardress of upper or lower::s>t=1,s<t=-1",
			"int strcmp2(string s,string t){",
			"\tint now=0;",
			"\twhile(tolower(s[now])==tolower(s[now])){",
			"\t\tif(s[now]=='\\0')return 0;",
			"\t\tnow++;",
			"\t}",
			"\treturn tolower(s[now])>tolower(t[now])? 1:-1;",
			"}"
		],
		"description": "文字の大小に関係なく小文字化して比較するスニペット"
	},
	"for":{
		"scope": "cpp",
		"prefix": "repp",
		"body": [
			"for(int $1 = $2;$1<=$3;$1++)"
		],
		"description": "forの省略"
	},
	"cout":{
		"scope": "cpp",
		"prefix": "co",
		"body": [
			"cout << $1 <<endl;"
		],
		"description": "改行付きの標準出力"
	},
	"cin":{
		"scope": "cpp",
		"prefix": "ci",
		"body": [
			"cin >> $1 ;"
		],
		"description": "標準入力"
	},
	"BITree":{
		"scope": "cpp",
		"prefix": "@bit",
		"body": [
			"struct BITree{",
			"\tint n;",
			"\tvector<int> tree;",
			"\tBITree(int n):n(n){",
			"\t\tinit();",
			"\t}",
			"\tvoid init(){",
			"\t\ttree.resize(n+1,0);",
			"\t}",
			"\t//結合法則が成り立つとき有効",
			"\tvoid add(int x,int a){",
			"\t\tif(x<=0)return;",
			"\t\tfor( x; x <= n; x += x&-x ){",
			"\t\t\ttree[x]+=a;",
			"\t\t}",
			"\t\treturn;",
			"\t}",
			"\t//結合法則が成り立つとき有効",
			"\tint getsum(int x){",
			"\t\tif(x<=0)return 0;",
			"\t\tint res=0;",
			"\t\tfor( x; x > 0; x -= x&-x ){",
			"\t\t\tres+=tree[x];",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"\t//これは逆元が存在して引き算ができるときに有効",
			"\tint getsum(int x,int y){",
			"\t\tif(y<x)swap(x,y);",
			"\t\treturn getsum(y)-getsum(x-1);",
			"\t}",
			"\t//各元が正であり、結合法則が成り立つときに有効",
			"\tint lower_bound(int a){",
			"\t\tint x=0,k=1;",
			"\t\twhile(2*k<=n)k*=2;",
			"\t\tfor( k; k>0; k/=2){",
			"\t\t\tif( x+k<=n && tree[x+k]<a ){",
			"\t\t\t\ta-=tree[x+k];",
			"\t\t\t\tx+=k;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn x+1;",
			"\t}",
			"};",
		],
	},
	"ExtendedEuclid":{
		"scope": "cpp",
		"prefix": "@euclid",
		"body": [
			"template<class A>",
			"pair<A,A> euclid(A a,A b,A &d){",
			"\tif(a==0)return {0,d/b};",
			"\telse if(b==0)return {d/a,0};",
			"\telse{",
			"\t\tif(a>=b){",
			"\t\t\tA x=a/b;",
			"\t\t\ta=a%b;",
			"\t\t\tpair<A,A> res=euclid(a,b,d);",
			"\t\t\treturn {res.first,res.second-x*res.first};",
			"\t\t}else{",
			"\t\t\tA x=b/a;",
			"\t\t\tb=b%a;",
			"\t\t\tpair<A,A> res=euclid(a,b,d);",
			"\t\t\treturn {res.first-x*res.second,res.second};",
			"\t\t}",
			"\t}",
			"}",
		],
		"description": "euclid(a,b,d)でax+by=dを満たす一つの解を出力"
	},
	"PTable":{
		"scope": "cpp",
		"prefix": "@ptable",
		"body": [
			"struct PTable{",
			"\tint n;",
			"\tvector<int> table;",
			"\tPTable(int n):n(n){",
			"\t\tcalc();",
			"\t}",
			"\tvoid calc(){",
			"\t\ttable.resize(n+1,1);",
			"\t\tfor(int i=2;i<=n;i++){",
			"\t\t\tif(table[i]!=1)continue;",
			"\t\t\tfor(int j=i;j<=n;j+=i){",
			"\t\t\t\ttable[j]=i;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\t//aが素数か判定",
			"\tint isPrime(int a) { if(a>=0)return a==table[a]&&a!=1;else return 0; }",
			"\t//aの最大の素因数を返して、aを割る",
			"\tint operator()(int &a){",
			"\t\tint x=table[a];",
			"\t\ta/=table[a];",
			"\t\treturn x;",
			"\t}",
			"\t//素因数分解::pfact(数字,いれもの)->{{素因数,個数}}",
			"\tvector<pair<int,int>> pfact(int a,vector<pair<int,int>> b){",
			"\t\tint mem=0,cou=0;",
			"\t\twhile(1){",
			"\t\t\tif(table[a]==1){",
			"\t\t\t\tb.push_back({mem,cou});",
			"\t\t\t\tbreak;",
			"\t\t\t}",
			"\t\t\tif(mem==table[a])cou++;",
			"\t\t\telse{",
			"\t\t\t\tif(cou!=0)b.push_back({mem,cou});",
			"\t\t\t\tmem=table[a];",
			"\t\t\t\tcou=1;",
			"\t\t\t}",
			"\t\t\ta/=table[a];",
			"\t\t}",
			"\t\treturn b;",
			"\t}",
			"\t//euler(a)を返す",
			"\tint euler(int a){",
			"\t\tint res=0;",
			"\t\tfor(int i=2;i<a;i++)if(table[i]==i)res++;",
			"\t\treturn res;",
			"\t}",
			"};",
		],
		"description":"Library for Prime number"
	},
	"op":{
		"scope": "op",
		"prefix": "op",
		"body": [
			"struct PTable{",
			"\tint n;",
			"\tvector<int> table;",
			"\tPTable(int n):n(n){",
			"\t\tcalc();",
			"\t}",
			"\tvoid calc(){",
			"\t\ttable.resize(n+1,1);",
			"\t\tfor(int i=2;i<=n;i++){",
			"\t\t\tif(table[i]!=1)continue;",
			"\t\t\tfor(int j=i;j<=n;j+=i){",
			"\t\t\t\ttable[j]=i;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\t//aが素数か判定",
			"\tint isPrime(int a) { if(a>=0)return a==table[a]&&a!=1;else return 0; }",
			"\t//aの最大の素因数を返して、aを割る",
			"\tint operator()(int &a){",
			"\t\tint x=table[a];",
			"\t\ta/=table[a];",
			"\t\treturn x;",
			"\t}",
			"\t//素因数分解::pfact(数字,いれもの)->{{素因数,個数}}",
			"\tvector<pair<int,int>> pfact(int a,vector<pair<int,int>> b){",
			"\t\tint mem=0,cou=0;",
			"\t\twhile(1){",
			"\t\t\tif(table[a]==1){",
			"\t\t\t\tb.push_back({mem,cou});",
			"\t\t\t\tbreak;",
			"\t\t\t}",
			"\t\t\tif(mem==table[a])cou++;",
			"\t\t\telse{",
			"\t\t\t\tif(cou!=0)b.push_back({mem,cou});",
			"\t\t\t\tmem=table[a];",
			"\t\t\t\tcou=1;",
			"\t\t\t}",
			"\t\t\ta/=table[a];",
			"\t\t}",
			"\t\treturn b;",
			"\t}",
			"\t//euler(a)を返す",
			"\tint euler(int a){",
			"\t\tint res=0;",
			"\t\tfor(int i=2;i<a;i++)if(table[i]==i)res++;",
			"\t\treturn res;",
			"\t}",
			"};",
		],
		"description":""
	},
}
